```{r echo=FALSE}
options(width=120)
knitr::opts_knit$set(verbose = TRUE)
knitr::opts_chunk$set(cache=TRUE)
```

Common analysis for all the experiments
========================================================

### Configuration

```{r comment=NA}
library(plyr)

exportInEnv <- function(X) {
  Name  <- X
  Value <- get(X)
  .Internal(Sys.setenv(Name, Value))
  cat( paste0("export ", paste(Name, Value, sep='='), "\n"))
}

LIBRARY        <- 'xxx'
MOIRAI_USER    <- 'xxx'
MOIRAI_PROJECT <- 'xxx'
GROUP_SHARED   <- 'xxx'
WORKDIR        <- '.'
GENE_SYMBOLS   <- paste(GROUP_SHARED, 'annotation/homo_sapiens/gencode-14/gencode.v14.annotation.genes.bed', sep='/')
ANNOTATION     <- paste(GROUP_SHARED, 'annotation/homo_sapiens/100712hg19/100712hg19', sep='/')
PROCESSED_DATA <- dirname( system( paste( 'ls -d /osc-fs_home/scratch/moirai/'
                                        , MOIRAI_USER
                                        , '/project/'
                                        , MOIRAI_PROJECT
                                        , '/'
                                        , LIBRARY
                                        , '*/Moirai.config'
                                        , sep='')
                                 , intern=TRUE)[1])

l_ply( c("LIBRARY", "MOIRAI_USER", "MOIRAI_PROJECT", "GROUP_SHARED"
         , "WORKDIR", "GENE_SYMBOLS", "ANNOTATION", "PROCESSED_DATA")
      , exportInEnv )
```

Cluster with the PromoterPipeline
---------------------------------

### Level 1

Transform the paired-end alignments into level 1 clusters, sort the file and index it. Select only BAM files that contain aligned reads.

```{r engine="bash"}
ALIGNED_DATA=$(for BAM in $PROCESSED_DATA/properly_paired_rmdup/*bam; do samtools flagstat $BAM | grep -Lq '^0 + 0 mapped' || echo $BAM ; done)

level1.py --help | head -n1

level1.py -o /dev/stdout -f 66 -F 516 $ALIGNED_DATA |
  bgzip > $LIBRARY.l1.gz
cat <(zgrep \# -A1 $LIBRARY.l1.gz) <(zgrep -v \# $LIBRARY.l1.gz | sed '1d' |
  sort --field-separator $'\t' -k2.4,2n -k 2.4,2.4 -k3,3n -k4,4n -k5,5) |
  bgzip |
  sponge $LIBRARY.l1.gz
#tabix -s2 -b3 -e4 $LIBRARY.l1.gz
```

### Level 2

Same for level 2 clusters.

Needs a version of level2.py that is more recent than 20120628
```{r engine="bash"}
level2.py --help | head -n1

level2.py -o /dev/stdout -t 0 $LIBRARY.l1.gz |
  bgzip > $LIBRARY.l2.gz
cat <(zgrep \# -A1 $LIBRARY.l2.gz) <(zgrep -v \# $LIBRARY.l2.gz | sed '1d' |
  sort --field-separator $'t' -k2.4,2n -k 2.4,2.4 -k3,3n -k4,4n -k5,5) |
  bgzip |
  sponge $LIBRARY.l2.gz
#tabix -s2 -b3 -e4 $LIBRARY.l2.gz
```

### Intersections

Convert level 1 and 2 files to BED format, and intersect them with pre-defined annotation files.

```{r engine="bash"}
function osc2bed {
  zcat $1 |
    grep -v \# |
    sed 1d |
    awk '{OFS="\t"}{print $2, $3, $4, "l1", "1000", $5}'
}

function bed2annot {
  bedtools intersect -a $1 -b $ANNOTATION.annot -s -loj |
    awk '{OFS="\t"}{print $1":"$2"-"$3$6,$10}' | 
    bedtools groupby -g 1 -c 2 -o collapse
}

for LEVEL in l1 l2
do
  osc2bed $LIBRARY.$LEVEL.gz | tee $LIBRARY.$LEVEL.bed | bed2annot - > $LIBRARY.$LEVEL.annot
done
```

### Gene symbols

```{r engine="bash"}
function bed2symbols {
  bedtools intersect -a $1 -b $GENE_SYMBOLS -s -loj |
    awk '{OFS="\t"}{print $1":"$2"-"$3$6,$10}' | 
    bedtools groupby -g 1 -c 2 -o distinct > $LIBRARY.l2.genes
}

if [ $GENE_SYMBOLS ]
then
  bed2symbols $LIBRARY.l2.bed > $LIBRARY.l2.genes
fi
```

